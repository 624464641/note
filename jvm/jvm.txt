1. 
2. 前端编译器 javac
    解释运行文件为.class文件

 jvm 流程信息

  2.运行时数据区信息 (runtime data area)
   1.多个线程共享方法区（method  area）去和堆 （ heap ）信息
   2. java栈（java stack）、 本地方法栈（native method stack）、程序计数器（program counter register）
   3. 本地方法接口（native interface ）， 执行引擎（exection engine）


   寄存器 ：
   栈：  跨平台性  指令集小 、 指令多


 2.第二次编译 是有calss文件编译成jit编译器

 3.jvm的生命周期
   1.启动：
     通过引导类加载器（bootstrap class loader） 创建一个初始类（initial class） 来完成 ， 这个类是由虚拟机的具体实现指定
   2.执行
   3.退出


第二章  ：
  类加载子系统
                                        类加载子系统
                                加载阶段                连接阶段     初始化阶段
                               引导类加载器             验证
1. 字节码文件（.class文件） —— > 扩展类加载器   ----->    准备 ----->  初始化
                               系统类加载器             解析

1.classloader 只负责class文件的加载  ， 至于它是否可以运行则有exectionengine决定
  1.class file 存在于本地硬盘上可以理解为设置师画在纸上的模板，文件要执行时需要加载到jvm中来，根据这个文件实例化处n个一抹一样的实例
  class file 加载到jvm中被称之为dna元数据模板 放在方法区
2.加载类信息存在于一块称为方法区的内存空间，除了类的信息外，方法区中还会存放运行时常量池信息，可能还包含字符串，字面量和数字常量信息


类的加载过程
 1. 先执行clint<static 方法 >父类的方法  然后再执行子类的<static>方法
 2.一个类的clint 在多线程下被同步加锁（也就是只会加载一次）

 类加载器的分类
  1. 引导类加载器 java的核心类库都是由引导类加载器加载的 （bootstrap classloader）
      用c++ 编写的  并且没有继承classloader ， 只加载包名为java javax sun开头的包

    2.自定义类加载器  - 扩展类加载器 extension classloader


 双亲委派机制
 1. java虚拟机对class文件加载是需要是才加载
    原理： 一个类加载器收到类加载的请求，并不是自己先加载，而是吧这个委托给父类加载器去执行
        如果父类加载器还存在父类加载则向上委托，依次递归请求将到达顶层的启动类加载器
        如果父类加载器可以完成类加载任务子类加载器才会尝试自己去加载这就是双亲委派机制
 沙箱安全机制

类加载器的引用
 jvm必须知道一个类型是由启动类加载还是有用户类加载，如果一个类型是由用户类加载的，
 那么jvm会将这个类加载器的一个引用作为类型信息的一部分保存在方法去内。当解析一个类的引用到另一个类型的
 引用的时候jvm需要保证这俩个类加载器是相同的