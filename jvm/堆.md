##### 堆得核心概述

1. 一个进程中得多个线程 共享堆空间

2. 一个进程对应一个jvm实例，一个jvm实例中有一个运行时数据区（runtime data area）

3. 每一个线程有独自的本地方法栈，程序计数器，

   1. 一个jvm实例只存在一个堆内存，java堆在jvm启动的时候创建，其空间大小也就确定了，是jvm管理的最大一个内存空间。

   2. 堆内存的大小是可以调节，堆可以处与物理上不连续的内存空间，但是在逻辑上被视为连续的。

      4.堆中每一个线程访问一块地址 为tlab

4. 数组和对象可能永远不会存储在栈上，因为栈帧中保存的是引用，这个引用指向对象或者数组在堆中的位置。
5. 在方法结束后，堆中的对象不会马上移除，仅仅在垃圾收集的时候才会被移除
6. 堆是gc执行垃圾回收的重要区域
7. gc 回收的堆是， 在栈中没有引用执行的堆内存

##### 设置堆大小与oom

1.-Xms10m（初始内存 ）  -Xmx10（最大内存）  堆的初始化大小和最大的 都是10m

2.xms 包含 年轻代+老年代

  2.1 -X jvm运行参数

3.Xmx 设置堆空间最大的空间大小

4. 查看设置参数 ， 

    4.1 jps命令

     4.2 jstat -gc 进程id

     4.3 VM options  -XX:+PrintGCDetails

##### 年期待与老年代

jdk 8 内存细分

1.新生区域 ，young 、 new

  1.eden区和survivor

2.养老区 old/tenure

3.元空间 meta

约定： 新生区-> 新生代->年轻代 ， 养老区-> 老年代->老年区 ， 永久区->永久代

4.



##### 图解对象分配过程

1. 存储在jvm中的java对象可以被划分俩类
   1. 一类是生命周期较为短的瞬时对象，这类对象的创建和消亡都非常迅速
   2. 另一类是生命周期非常长的在某些极端的情况下还 能与jvm的生命周期保持一致 
2. java堆区进一步细分可以分为年轻代和老年代，其中**年轻代**又可以划分为*eden* 空间，*survivoro* 空间和*survivor*空间 （有时也叫做from区和，to区）
3. 新生代与老年代大小比例
   1. 默认是 2 （新生代： 老年代 = > 1:2）--XX :NewRation = 2 
4. 对象分配过程 
   1. 针对幸存者s0,s1区的总结 ， 复制之后又交换，谁空谁是to
   2. 关于垃圾回收，频繁在新生区收集，很少在养老区收集，几乎不再元空间和永久区收集

##### minor gc major gc full gc

1. 部分收集，不是完整的收集整个java堆得垃圾收集，其中又分为：

   1. 新生代收集（minor gc / younggc） 只是新生代的垃圾收集

   2. 老年代收集（majorgc/ oldgc） 只是老年代的垃圾收集

      2. 1目前只有CMS GC会有单独收集老年代的行为
      3. 很多时候majorgc和oldgc混淆使用具体分别是老年代回收还是整堆回收

   3. 混合收集（mixed gc） 收集整个新生代以及部分老年代的垃圾收集

        3.1 目前是有g1gc会有这种行为

   4. 整堆收集（full gc） 收集整个java堆和方法区的垃圾收集

##### 年轻代GC (Minor gc )触发机制

1.  当年轻代空间不足 ，就会触发minor gc 这里的年轻代满指的是eden代满，survicor 满不会引发gc （每次 minor gc会清理年轻代的内存）
2. 因为java对象大多数都具备朝生熄灭的特性，所以minor gc非常频繁，一般回收速度也比较快，这一定义既清晰有易于理解
3. minor gc会引发stw 暂停其他用户的线程 ，等垃圾回收结束，用户才可以的到请求响应

##### 堆空间为什么要分代

1. 研究不同对象的生命周期不同，70-90%都是零食对象
   1. 新生代有eden ， s1 s0 俩个大小相同的
   2. 老年代 ，存放新生代经历多次gc任然存活
2. 堆空间的参数设置：
   1. -XX：+PrintFlagInitial : 查看所有的参数的默认初始值
   2. -Xms： 设置堆空间内存
   3. -Xmx设置堆最大内存
   4. -Xmn ： 设置新生代的大小
   5. -XX:Newtaion : 设置新生代与老年代在堆结构的占

#####  堆空间是分配对象的唯一选择么

1.  如果对象经过逃逸分析后发现，一个对象并没有逃逸出方法，那么就可以在**栈上分配**。
2. **同步策略** 如果一个对象发现只能被一个线程访问到，那么这个对象可以不考虑同步
3.  分离对象和标量替换，有的对象可能不需要作为一个连接的内存结构存在，也可以被访问到，那么对象的部分可以不存储在内存，而是存储在cpu的寄存器中。
4.  逃逸分析  只有在服务器端才可以使用

