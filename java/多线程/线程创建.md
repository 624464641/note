##### 创建线程

1. 继承thread类 重写run方法

   1. thread 类也实现了runnable接口

2. 实现 Runnable 接口 重写run方法

3. 以上俩种 没有返回值 

4.  Callable 接口 有返回值

   1.启动callable线程
   
   ~~~ java
   FutureTask task = new FutureTask(new Callable());
   new Thread(task).start();
   ~~~
   
   

#### 线程池

jdk1.5 开始 使用 Executor 创建线程池  , Executor顶级类

1. 优点： 避免线程创建和销毁带来的性能开销

2. 避免大量的线程因抢占系统资源导致的阻塞现象

3. 能够对线程提供简单的管理并且提供定时执行，间隔执行等功能

   Executors   只是线程池的工具类

##### executor 和submit的区别

1. executor void 没有返回值

   1. ~~~ java
      void executor
      ~~~

2. sumbit 有返回值

   ~~~ java
     <T> Future<T> submit(Callable<T> task);
   ~~~


##### 线程中断

1. 使用interrupt 方法不会真正的结束线程，只是在当前线程中打一个停止的标记

##### 暂停线程

1. suspend() 暂停线程
   1. 如果线程访问方法有锁 ， 则会独占次方法，其他的线程无法进入

2. resume () 让暂停的线程继续 开始运行 

##### yield 方法

1.放弃当前cpu资源，将资源让给其他任务去占用cpu，当时放弃时间不确定，也许刚刚放弃，又可以马上获取cpu资源。

##### 线程优先级

1. 在操作系统中线程是可以划分优先级的，优先级高的线程，获取cpu资源更多，也就是cpu会执行优先级比较高的线程任务，设置线程优先级有助于帮助【线程调度器】确定在下一次选择哪一个线程优先执行
2. 设置线程优先级 方法 t.setPriority(Thread.MAX_PRIORITY);
3. 获取线程优先级t.getPriority()
4. 线程优先级具有继承性

##### 守护线程

1. java线程分为俩种一种是用户线程， 一种是守护线程。

2. 守护线程是一种特殊的线程，特殊指的是当进程中不存在用户 线程时，守护线程会自动的销毁，最典型的守护线程例子，就是垃圾回收线程就没有存在的 必要，所以会自动的销毁。

3. ```java
   t.setDaemon(true)
   ```

   在启动线程之前设置为守护线程。



##### 线程同步

1. 局部变量是线程安全的 ，
2. 成员变量不是线程安全的

#### synchronized 关键字

1. 作用在方法上时 ， 是只可以有一个线程访问的，其他线程需要等这个访问线程完毕以后才可以继续访问

2. 俩个对象，俩个线程时：synchronized 取得的锁都是对象锁，而不是把一段代码，一个方法作为锁，所以哪一个线程先执行待synchronized关键字的方法，那个方法就持有该方法所属对象的锁，

   其他线程只能呈等待状态的，前提是多个线程访问同一个对象。如果多个线程访问多个对象，则jvm会创造多个对象锁。

3. synchronized 修饰的方法在某一个（obj）对象中 ， 如果线程a访问obj对象则，线程b就不能访问到obj对象，需等待线程a执行完成以后才能访问obj对象，所以synchronized锁定的是整个obj对象，而不是某一个方法。线程b可以异步的调用obj中没有使用synchronize 修饰的方法

4. 多线程会导致脏读： 比如全局变量name 方法a修改 值为 b 方法B读取a的值时，如果为异步则可能读取到被修改之前的值，

5. 锁重入

   关键字synchronized拥有锁重入的功能，也就是说再使用synchronized时，当一个线程得到一个对象锁后，再次请求对象锁时是可以得到该对象锁 

6. 锁的自动释放

   1.当锁的方法发生异常后，锁会自动发开释放掉

7. 锁不具有继承性

   ##### synchronize 方法缺点

   1. synchronize同步代码块和synchronize同步方法效果是一样的 ， 

8. java可以使用任意对象作为对象锁

   1.   在多个线程持有对象锁为同一个对象的情况下，同一时间只有一个线程可以执行带有synchronized代码块
   2. 非this对象锁的有点： 一个类有很多synchronized（this） 方法，虽然可以实现同步，但是受到阻塞，所以影响运行效率，如果使用同步代码非this对象，则synchronized 非this方法的代码块中的程序与同步方法是异步的，不予其他的争抢this锁。